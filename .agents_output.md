# SQUASH REFACTORING - Map Interaction Architecture

## Executive Summary

This document describes the **target architecture** for map interactions, based on the requirements:
1. Use **native OSM labels** (`place_label_city`, `place_label_other`) directly
2. Use **feature-state** as the **ONLY** mechanism for `hover` / `selected` / `hasData` styling
3. **Eliminate custom hitbox layers** - interact with labels directly
4. **Polygons** for hit-testing only (not for labeling)
5. Single unified interaction service

---

## Current Architecture Analysis

### What Exists Today

| File | Lines | Purpose | Status |
|------|-------|---------|--------|
| `cityInteractiveLayer.ts` | ~160 | Creates invisible circle hitbox layers duplicating labels | **OBSOLETE** |
| `cityHighlightLayers.ts` | ~155 | Sets `hover`/`selected` feature-state on managed labels | **KEEP (simplified)** |
| `interactiveLayers.ts` | ~170 | `CityIdentity` type + `extractCityIdentity()` | **SIMPLIFY** |
| `mapInteractionService.ts` | 774 | Main interaction handler with async resolution | **REWRITE** |
| `layers/managedCityLabels.ts` | ~232 | Splits OMT label layers into managed/base | **KEEP** |
| `layers/baseLabels.ts` | ~60 | Place class filter builders | **KEEP** |
| `registry/layerRegistry.ts` | ~140 | Layer ID constants and helpers | **KEEP (remove hitbox refs)** |
| `mapSelection.ts` | 17 | `MapSelection` union type | **KEEP** |

### Current Flow (Complex)

```
┌─────────────────────────────────────────────────────────────────────────┐
│  mousemove / click                                                      │
└────────────────────────────┬────────────────────────────────────────────┘
                             ▼
┌─────────────────────────────────────────────────────────────────────────┐
│  queryRenderedFeatures(point, { layers: [hitbox layers] })              │
│  - city-hitbox::place_label_city__managed                               │
│  - city-hitbox::place_label_other__managed                              │
└────────────────────────────┬────────────────────────────────────────────┘
                             ▼
┌─────────────────────────────────────────────────────────────────────────┐
│  extractCityIdentity(feature)                                           │
│  - reads insee, name:fr, name, class, rank, capital, etc.               │
│  - builds CityIdentity with 11+ fields                                  │
└────────────────────────────┬────────────────────────────────────────────┘
                             ▼
┌─────────────────────────────────────────────────────────────────────────┐
│  resolveCityIdentity() - async resolution chain                         │
│  - if no inseeCode: resolveCommuneByClick (spatial index)               │
│  - if still unresolved: resolveNearestCommuneInsee (fallback)           │
└────────────────────────────┬────────────────────────────────────────────┘
                             ▼
┌─────────────────────────────────────────────────────────────────────────┐
│  resolveMapSelection()                                                  │
│  - differentiates commune vs infraZone by placeClass                    │
│  - returns MapSelection                                                 │
└────────────────────────────┬────────────────────────────────────────────┘
                             ▼
┌─────────────────────────────────────────────────────────────────────────┐
│  setHoveredCity() / setSelectedCity()                                   │
│  - sets feature-state on HITBOX layer (wrong!)                          │
│  - should be on managed label layer                                     │
└─────────────────────────────────────────────────────────────────────────┘
```

### Problems with Current Architecture

1. **Hitbox layers are unnecessary** - MapLibre can query symbol layers directly
2. **Event handlers are disabled** - Lines 195-197 are commented out (`// map.on("mousemove"...`)
3. **Feature-state targets hitbox layers** - Style expressions are on managed labels, not hitbox
4. **774 lines for simple hover/click** - Over-engineered async resolution
5. **CityIdentity has 11+ fields** - Most are never used
6. **Duplicate source tracking** - Hitbox layers duplicate the managed label source

---

## Target Architecture

### Core Principles

1. **Direct label interaction** - Query `place_label_city__managed` and `place_label_other__managed` directly
2. **Single event handler** - One `mousemove`, one `click`, done
3. **Feature-state on labels** - Hover/selected styling applied to managed label layers
4. **Spatial index for data enrichment** - `hasData` flag from `communeSpatialIndex` / `infraZoneSpatialIndex`
5. **Synchronous where possible** - Spatial index lookups are sync after initial load

### New Flow (Simple)

```
┌─────────────────────────────────────────────────────────────────────────┐
│  mousemove / click                                                      │
└────────────────────────────┬────────────────────────────────────────────┘
                             ▼
┌─────────────────────────────────────────────────────────────────────────┐
│  queryRenderedFeatures(point, { layers: managedLabelLayers })           │
│  - place_label_city__managed                                            │
│  - place_label_other__managed                                           │
└────────────────────────────┬────────────────────────────────────────────┘
                             ▼
┌─────────────────────────────────────────────────────────────────────────┐
│  extractLabelIdentity(feature)                                          │
│  - feature.id (stable, from tile source)                                │
│  - feature.source / feature.sourceLayer                                 │
│  - feature.properties.name / name:fr                                    │
│  - feature.properties.class                                             │
└────────────────────────────┬────────────────────────────────────────────┘
                             ▼
┌─────────────────────────────────────────────────────────────────────────┐
│  resolveSpatialIndex(lngLat, labelName, placeClass)                     │
│  - if commune class → communeSpatialIndex.resolveCommuneByClick()       │
│  - if infra class → infraZoneSpatialIndex.resolveInfraZoneByClick()     │
│  - returns { inseeCode, name, hasData } or null                         │
└────────────────────────────┬────────────────────────────────────────────┘
                             ▼
┌─────────────────────────────────────────────────────────────────────────┐
│  setFeatureState(map, feature, { hover: true, hasData: true })          │
│  - applies directly to managed label layer                              │
│  - styling expressions read feature-state                               │
└─────────────────────────────────────────────────────────────────────────┘
```

### Files to DELETE (or empty completely)

| File | Reason |
|------|--------|
| `cityInteractiveLayer.ts` | Hitbox layers no longer needed |

### Files to SIMPLIFY

| File | Changes |
|------|---------|
| `interactiveLayers.ts` | Remove 80% - keep only `extractLabelIdentity()` with 4 fields |
| `mapInteractionService.ts` | Rewrite from 774 lines to ~200 lines |
| `registry/layerRegistry.ts` | Remove `buildCityHitboxLayerId`, `extractLabelLayerIdFromHitbox`, `isCityHitboxLayer` |

### Files to KEEP as-is

| File | Reason |
|------|--------|
| `mapSelection.ts` | Clean, minimal, fits target architecture |
| `layers/managedCityLabels.ts` | Correctly builds feature-state expressions |
| `layers/baseLabels.ts` | Simple filter builders |
| `cityHighlightLayers.ts` | Minor changes - target managed layers instead of hitbox |

---

## Type Simplifications

### Current `CityIdentity` (11+ fields)

```typescript
type CityIdentity = {
    id: string;
    name: string;
    inseeCode?: string | null;
    resolutionMethod?: CityResolutionMethod;
    resolutionStatus?: "resolved" | "unresolved";
    unresolvedReason?: string | null;
    placeClass?: CityPlaceClass | null;
    location?: { lng: number; lat: number } | null;
    rank?: number | null;
    capitalType?: string | null;
    propertiesSnapshot?: Record<string, unknown> | null;
};
```

### Target `LabelIdentity` (5 fields)

```typescript
type LabelIdentity = {
    featureId: string | number;       // feature.id from tile
    source: string;                   // feature.source
    sourceLayer: string | undefined;  // feature.sourceLayer
    name: string;                     // display name
    placeClass: string | null;        // "city" | "town" | "village" | "suburb" | "neighbourhood"
};
```

### Feature State Flags

```typescript
// Applied to managed label layers
type LabelFeatureState = {
    hover?: boolean;      // Mouse is over this label
    selected?: boolean;   // User clicked this label
    hasData?: boolean;    // Spatial index has data for this location (future use)
};
```

---

## End-to-End Flow

### Hover Flow

1. User moves mouse over map
2. `mousemove` handler triggers (throttled 60ms)
3. `queryRenderedFeatures(point, { layers: MANAGED_LABEL_LAYER_IDS })`
4. If feature found:
   - Extract `LabelIdentity`
   - Clear previous hover feature-state
   - Set `hover: true` on new feature
5. If no feature found:
   - Clear previous hover feature-state

### Click Flow

1. User clicks on map
2. `click` handler triggers
3. `queryRenderedFeatures(point, { layers: MANAGED_LABEL_LAYER_IDS })`
4. If feature found:
   - Extract `LabelIdentity`
   - Determine if commune or infraZone by `placeClass`
   - Resolve via spatial index using `(lngLat, name, placeClass)`
   - If resolved → build `MapSelection`, emit event, set `selected: true`
   - If unresolved → ignore click (don't select unresolvable labels)
5. If no feature found:
   - Clear selection

### `hasData` Flow (Future Enhancement)

When data aggregates are loaded:
1. For each label on screen, check if spatial index has data
2. Set `hasData: true` on labels that have associated data
3. Style expressions render labels differently based on `hasData`

---

## Implementation Plan

### Phase 1: Delete Obsolete Code

1. Remove `cityInteractiveLayer.ts`
2. Remove hitbox-related functions from `registry/layerRegistry.ts`:
   - `buildCityHitboxLayerId`
   - `extractLabelLayerIdFromHitbox`
   - `isCityHitboxLayer`
   - `LAYER_IDS.cityHitboxPrefix`
3. Remove `ensureCommuneInteractiveLayers()` calls from `vector-map.tsx`

### Phase 2: Simplify `interactiveLayers.ts`

Replace with minimal `LabelIdentity` type and `extractLabelIdentity()` function.

### Phase 3: Rewrite `mapInteractionService.ts`

New structure (~200 lines):
```typescript
export function attachMapInteractionService(
    map: MapLibreMap,
    onSelect: (selection: MapSelection | null) => void,
    options?: { debug?: boolean }
): () => void {
    // Single hover state
    // Single selected state
    // Two event handlers: mousemove, click
    // Synchronous spatial index lookups
}
```

### Phase 4: Update `cityHighlightLayers.ts`

Ensure feature-state targets managed label layers (already does, but verify).

### Phase 5: Update `vector-map.tsx`

- Remove `interactiveLayerIdsRef`
- Simplify `setupInteractiveLayers()` 
- Remove `CommuneInteractiveLayerHandle` usage

---

## Expected Results

| Metric | Before | After |
|--------|--------|-------|
| Lines in `mapInteractionService.ts` | 774 | ~200 |
| Files in interaction system | 7 | 5 |
| Event handlers | 3+ (commented out) | 2 |
| Async operations on hover | 2-3 | 0 |
| `CityIdentity` fields | 11 | 5 |

---

## Confirmation Checklist

Before proceeding, confirm:

- [ ] Delete `cityInteractiveLayer.ts` entirely
- [ ] Remove hitbox functions from `registry/layerRegistry.ts`
- [ ] Rewrite `mapInteractionService.ts` to ~200 lines
- [ ] Simplify `CityIdentity` → `LabelIdentity` (5 fields)
- [ ] Keep `managedCityLabels.ts` as-is
- [ ] Keep `mapSelection.ts` as-is
- [ ] Update `vector-map.tsx` to use simplified service

**AWAITING CONFIRMATION BEFORE IMPLEMENTATION**
